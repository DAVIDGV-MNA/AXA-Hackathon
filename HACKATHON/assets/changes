<script>
(function(){
  let chatHistory = [];
  let waiting = false;

  function renderChat() {
    const ctx = document.getElementById('chat-context');
    if (!ctx) return;
    if (chatHistory.length === 0) {
      ctx.innerHTML = '<div style="text-align:center;color:var(--muted);padding:40px 0;">No messages yet</div>';
    } else {
      ctx.innerHTML = chatHistory.map(m => {
        const align = m.role === 'user' ? 'flex-end' : 'flex-start';
        return `
          <div style="display:flex; justify-content:${align}; margin:8px 0;">
            <div style="max-width:78%; padding:10px 14px; border-radius:12px; background:${m.role==='user'? 'linear-gradient(180deg,var(--panel),var(--tile))' : 'var(--panel)'}; color:var(--text); box-shadow:0 1px 0 rgba(0,0,0,0.02);">
              <div style="font-size:12px; color:var(--muted); margin-bottom:6px;">${m.role==='user' ? 'You' : 'Assistant'}</div>
              <div style="white-space:pre-wrap;">${escapeHtml(m.content)}</div>
            </div>
          </div>`;
      }).join('') + (waiting ? '<div style="color:var(--muted); padding:8px 0;">Assistant is typing...</div>' : '');
    }
    ctx.style.display = 'block';
    ctx.scrollTop = ctx.scrollHeight;
  }

  function escapeHtml(t=''){return t.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');}

  // ----- Core: Chat call through your proxy -----
  async function callSecureGPTChat(messages) {
    // messages: [{role:"user"|"assistant"|"system", content:"..."}]
    const payload = {
      api_version: SECUREGPT_CONFIG.API_VERSION || "",
      url_version: SECUREGPT_CONFIG.URL_VERSION || "",
      model_url: SECUREGPT_CONFIG.MODEL_URL || "",
      messages
    };

    const res = await fetch(SECUREGPT_PROXY.CHAT, {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(payload)
    });

    const text = await res.text();
    let data; try { data = JSON.parse(text); } catch { data = { raw: text }; }

    if (!res.ok) {
      console.error("SecureGPT chat error", res.status, data);
      throw new Error(`SecureGPT chat error ${res.status}: ${text}`);
    }

    // Expecting OpenAI-like shape from the proxy:
    // { choices: [ { message: { role: "assistant", content: "..." } } ] }
    return data?.choices?.[0]?.message?.content || "";
  }

  // ----- Embeddings helper (optional; call when you need vectors) -----
  async function callSecureGPTEmbeddings(inputs) {
    // inputs: string | string[]
    const payload = {
      api_version: SECUREGPT_CONFIG.API_VERSION || "",
      url_version: SECUREGPT_CONFIG.URL_VERSION || "",
      embeddings_url: SECUREGPT_CONFIG.EMBEDDINGS_URL || "",
      model: SECUREGPT_CONFIG.AXA_SECUREGPT_EMBEDDINGS_MODEL || "",
      input: inputs
    };

    const res = await fetch(SECUREGPT_PROXY.EMBED, {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(payload)
    });

    const text = await res.text();
    let data; try { data = JSON.parse(text); } catch { data = { raw: text }; }

    if (!res.ok) {
      console.error("SecureGPT embeddings error", res.status, data);
      throw new Error(`SecureGPT embeddings error ${res.status}: ${text}`);
    }

    // Expecting { data: [ { embedding: number[] }, ... ] }
    return data?.data || [];
  }

  // ----- Keep your existing UI wiring (send button, enter-to-send, etc.) -----
  function startChatUI(){
    const selector = document.getElementById('agent-selector');
    if (selector) selector.style.display = 'none';
    const ctx = document.getElementById('chat-context');
    if (ctx) ctx.style.display = 'block';
    const input = document.querySelector('.chat-input');
    if (input) input.placeholder = 'Type a message...';
  }
  window.startChatUI = startChatUI;

  function rebindControls(){
    const sendBtn = document.querySelector('.action-btn.send');
    const textarea = document.querySelector('.chat-input');
    if (!sendBtn || !textarea) return;

    const newSend = sendBtn.cloneNode(true);
    sendBtn.parentNode.replaceChild(newSend, sendBtn);
    const newTextarea = textarea.cloneNode(true);
    textarea.parentNode.replaceChild(newTextarea, textarea);

    const inputEl = document.querySelector('.chat-input');
    const sendEl = document.querySelector('.action-btn.send');

    sendEl.addEventListener('click', async function(){
      const text = inputEl.value.trim();
      if (!text) return;
      if (document.getElementById('agent-selector')?.style.display !== 'none') startChatUI();

      chatHistory.push({ role: 'user', content: text });
      inputEl.value = '';
      waiting = true; renderChat();

      try {
        const msgs = chatHistory.map(m => ({ role: m.role, content: m.content }));
        const reply = await callSecureGPTChat(msgs);
        chatHistory.push({ role: 'assistant', content: reply || '(empty reply)' });
      } catch (err) {
        chatHistory.push({ role: 'assistant', content: 'Error contacting SecureGPT. Check console.' });
      }
      waiting = false; renderChat();
    });

    inputEl.addEventListener('keydown', function(e){
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        document.querySelector('.action-btn.send').click();
      }
    });
  }

  // Minimal public API so your conversation manager keeps working
  window.chatAPI = {
    setHistory(messages){ chatHistory = Array.isArray(messages)? messages.map(m=>({role:m.role,content:m.content})) : []; renderChat(); },
    getHistory(){ return chatHistory.slice(); },
    pushUserMessage: async function(text){
      if (!text) return;
      chatHistory.push({ role:'user', content:text }); waiting=true; renderChat();
      try {
        const reply = await callSecureGPTChat(chatHistory.map(m=>({role:m.role,content:m.content})));
        chatHistory.push({ role:'assistant', content: reply });
      } catch {
        chatHistory.push({ role:'assistant', content:'Error contacting SecureGPT.'});
      }
      waiting=false; renderChat();
    }
  };

  document.addEventListener('DOMContentLoaded', function(){
    renderChat();
    rebindControls();
  });
})();
</script>
