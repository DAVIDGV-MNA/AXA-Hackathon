// server.js
import express from "express";
import fetch from "node-fetch";
import cors from "cors";

const app = express();
app.use(cors());
app.use(express.json());

// Load env (set these in your .env or hosting platform)
const {
  SECUREGPT_CLIENT_ID,
  SECUREGPT_CLIENT_SECRET,
  SECUREGPT_URL_TOKEN,            // OAuth2 token endpoint
  SECUREGPT_API_VERSION,          // e.g., "2024-06-01"
  SECUREGPT_MODEL_URL,            // Chat/completions base URL
  AXA_SECUREGPT_EMBEDDINGS_MODEL, // Embeddings model name
  SECUREGPT_URL_EMBEDDINGS,       // Embeddings endpoint
  SECUREGPT_URL_VERSION           // e.g., "v1"
} = process.env;

// Cache token in-memory (optional)
let cachedToken = null;
let tokenExpiry = 0;

async function getAccessToken() {
  const now = Math.floor(Date.now()/1000);
  if (cachedToken && now < tokenExpiry - 60) return cachedToken;

  const body = new URLSearchParams({
    grant_type: "client_credentials",
    client_id: SECUREGPT_CLIENT_ID,
    client_secret: SECUREGPT_CLIENT_SECRET,
    // Some IdPs require 'scope' or 'audience' â€” add if needed
  });

  const res = await fetch(SECUREGPT_URL_TOKEN, {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body
  });

  if (!res.ok) {
    const t = await res.text();
    throw new Error(`Token error ${res.status}: ${t}`);
  }

  const data = await res.json();
  cachedToken = data.access_token;
  tokenExpiry = data.expires_in ? now + data.expires_in : now + 300; // fallback 5 min
  return cachedToken;
}

// --- Public, safe endpoints the browser calls ---

app.post("/securegpt/token", async (_req, res) => {
  // Optional: disable this route in production if not needed by clients
  try {
    const token = await getAccessToken();
    res.json({ access_token: token, expires_in: Math.max(0, tokenExpiry - Math.floor(Date.now()/1000)) });
  } catch (e) {
    res.status(500).json({ error: String(e) });
  }
});

app.post("/securegpt/chat", async (req, res) => {
  try {
    const token = await getAccessToken();
    const { api_version, url_version, model_url, messages } = req.body;

    // Shape your outbound request to SecureGPT. Below assumes OpenAI-like semantics.
    const outboundBody = {
      // If SecureGPT requires a 'model' string, add it here, e.g.: model: "gpt-4o-secure"
      messages
    };

    const headers = {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${token}`
    };

    // Some gateways use version header; others use query param (?api-version=)
    // Adjust as required by SecureGPT:
    if (api_version) headers["x-api-version"] = api_version;
    if (url_version) headers["x-url-version"] = url_version;

    const chatUrl = model_url || SECUREGPT_MODEL_URL;

    const upstream = await fetch(chatUrl, {
      method: "POST",
      headers,
      body: JSON.stringify(outboundBody)
    });

    const text = await upstream.text();
    res.status(upstream.status).type(upstream.headers.get("content-type") || "application/json").send(text);
  } catch (e) {
    res.status(500).json({ error: String(e) });
  }
});

app.post("/securegpt/embeddings", async (req, res) => {
  try {
    const token = await getAccessToken();
    const { api_version, url_version, embeddings_url, model, input } = req.body;

    const headers = {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${token}`
    };
    if (api_version) headers["x-api-version"] = api_version;
    if (url_version) headers["x-url-version"] = url_version;

    const outboundBody = { model: model || AXA_SECUREGPT_EMBEDDINGS_MODEL, input };

    const upstream = await fetch(embeddings_url || SECUREGPT_URL_EMBEDDINGS, {
      method: "POST",
      headers,
      body: JSON.stringify(outboundBody)
    });

    const text = await upstream.text();
    res.status(upstream.status).type(upstream.headers.get("content-type") || "application/json").send(text);
  } catch (e) {
    res.status(500).json({ error: String(e) });
  }
});

const PORT = process.env.PORT || 3001;
app.listen(PORT, () => console.log(`SecureGPT proxy running on http://localhost:${PORT}`));
