@app.post("/rag/query")
def rag_query(body: QueryIn):
    idx, m = ensure_index_ready()
    if idx is None or idx.ntotal == 0:
        return {"answer": "No documents indexed yet. Upload files into ./uploads and call /rag/reindex.", "sources": []}

    qvec = embed_texts([body.query]).astype(np.float32)
    faiss.normalize_L2(qvec)

    # Pull a bigger candidate pool so filters wonâ€™t starve results
    pool = max(body.top_k * 6, 30)
    D, I = idx.search(qvec, pool)
    I = I[0].tolist()
    scores = D[0].tolist()

    def passes_filters(rmeta: Dict[str, Any]) -> bool:
        if body.doc_types:
            if (rmeta.get("doc_type") or "other") not in set([d.lower() for d in body.doc_types]):
                return False
        if body.must_keywords:
            kws = set((rmeta.get("keywords") or []))
            need = {k.lower() for k in body.must_keywords}
            if not need.issubset(kws):
                return False
        p = (rmeta.get("path") or "").lower()
        if body.include_paths and not any(s.lower() in p for s in body.include_paths):
            return False
        if body.exclude_paths and any(s.lower() in p for s in body.exclude_paths):
            return False
        return True

    picked, context_snips, sources = 0, [], []
    for row, score in zip(I, scores):
        if picked >= body.top_k:
            break
        if 0 <= row < len(m):
            mr = m[row]
            if passes_filters(mr):
                context_snips.append(mr["text"])
                sources.append({
                    "path": mr["path"],
                    "page": int(mr.get("page", 1)),
                    "score": round(float(score), 4),
                    "title": mr.get("title"),
                    "doc_type": mr.get("doc_type"),
                    "keywords": mr.get("keywords", []),
                })
                picked += 1

    if not context_snips:
        return {"answer": "No results matched your filters.", "sources": []}

    try:
        answer = llm_answer(body.query, context_snips)
    except requests.HTTPError as e:
        raise HTTPException(status_code=502, detail=f"SecureGPT chat error: {e}")

    return {"answer": answer, "sources": sources}